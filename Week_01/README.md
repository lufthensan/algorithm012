数组

数组的实现

不同的语言有不同的构造方法，内容本质是泛型，不局限于数值类型

# Java,C++:
int a[100]

# Python:
list = []

# Javascript:
let x = [1,2]
数组在内存中的表现

如下图查找数据时，可以直接找到下表对应的地址，因此时间复杂度是O(1)O(1) image

Array增加流程

增加流程如下图，如果要在一个数组中新增一个数据，需要先把插入位置及之后的数据向后挪动一位，再进行插入操作，因此插入操作的时间复杂度是O(n)O(n)。 image image image

同理，删除元素的话，从指定位置移除元素后，后面位置的数值需要往前移动一位。
image image image

数组Array的时间复杂度与空间复杂度

操作	时间复杂度	空间复杂度
prepend		
append		
lookup	O(1)	
insert	O(n)	
delete	O(n)	
Linked List链表

单项链表

链表是有Head\Tail
链表的特性是在Next中存放着下一个元素的地址，因此空间上并不是紧靠在一起的。最后一个链表的next指向null。
图中表示的是单向连接，如果箭头是双向的，也就是双向链表。如果最后一个元素的next存放的是head的地址，那么就会回环链表。

链表的增加与删除操作

image image 如果链表要新增一个元素，新增位置后面的元素并不需要进行迁移变动，只需要将前一个的next指针地址指向新元素地址，同时新元素地址指向原插入位置元素的地址即可。因此时间复杂度上是O(1)O(1) image 同理，删除节点的话，也是直接将目标节点删除，前面节点的Next指向后面节点的位置即可。 image

双向链表

双向量表多了一个Previous来存储前面一个元素的地址 image

链表的复杂度

链表的插入和删除操作很快，但是缺点是查询的时候，就必须从head开始，一个个查询链表，直到查到目标元素位置，因此查询的时间复杂度为O(n)。

操作	时间复杂度
prepend	O(1)
append	O(1)
lookup	O(n)
insert	O(1)
delete	O(1)
Skip List 跳表

因为链表的读性能时间复杂度相对数组来说还是很慢的O(n)，因此后面就有跳表。跳表是使用空间来换取时间。
注意：跳表只能用于元素有序的情况。
所以，跳表(skip list)对标的是平衡树(AVL Tree)和二分查找，是一种 插入/删除/搜素 都是O(\log_2{n})O(log 
2
​	 n)。1989年出现，晚于其他数据结构。

最大的优势是原理简单、容易实现、方便扩展、效率更高。因此在一些热梦的项目里用来带起平衡树，如Redis、LevelDB image image image image

跳表查询的时间复杂度分析

间隔为2的话，分级节点分别是n/2、n/4、n/8，因此，第k级索引节点的个数就是n/(2^k)n/(2 
k
 )
假设索引有h级，最高级的索引有2个节点。n/(2^k)=2n/(2 
k
 )=2,从而得到h=\log_2{(n)}-1h=log 
2
​	 (n)−1

如果把每级基数2变成3，就如下图 image

实际应用中因为跳表的插入与删除操作，会导致每级对应的有可能不那么准确，就会导致时间复杂度不一，有可能操作步骤变少，也有可能变多。 image

跳表的空间复杂度分析

原始列表大小为n，每2个节点抽1个，每层索引的节点数为：

n/2,n/4,n/8,...,8,4,2n/2,n/4,n/8,...,8,4,2
原始列表大小为n，每2个节点抽1个，每层索引的节点数：

n/3,n/9,n/27,...9,3,1
空间复杂度是O(n)O(n)，推导如下：第一层n，第二层n/2，第三层n/2^2n/2 
2
 ...，直到n/2^{logn} = 1n/2 
logn
 =1，所以，空间需求为

S=n+n/2+n/2^2+...+n/2^{logn}<n(1+1/2+1/2^2+...+1/2^\propto)=2nS=n+n/2+n/2 
2
 +...+n/2 
logn
 <n(1+1/2+1/2 
2
 +...+1/2 
∝
 )=2n
因此空间复杂度为2n=O(n)
